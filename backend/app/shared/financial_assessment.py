"""
Financial Health Assessment - Debt Composition Risk Module

This module produces a Debt Composition Risk Score (0-100), structured financial
interpretation, and personalized UX copy generated by an LLM using controlled
prompts and backup UX language.

Architecture:
1. Deterministic Calculation Layer - Computes risk score
2. Deterministic Financial Interpretation Layer - Rule-based interpretation
3. AI-Generated UX Copy Layer - LLM-generated personalized messaging

Enhancements:
- debt_count in deterministic output for concrete LLM coaching
- driver_severity sorted by weighted score impact (D×50, H×30, C×20)
- Dynamic interpretation points with actual data/percentages
- primary_driver field to anchor summary and reduce LLM complexity
"""

from typing import List, Dict, Any, Optional, Literal
from pydantic import BaseModel, Field
from enum import Enum
import logging

logger = logging.getLogger(__name__)


# ============================================================================
# Type Definitions
# ============================================================================

class RiskBand(str, Enum):
    """Risk band classifications"""
    EXCELLENT = "excellent"
    LOW_MODERATE = "low_moderate"
    MODERATE = "moderate"
    HIGH = "high"
    CRITICAL = "critical"


class DriverType(str, Enum):
    """Risk driver types"""
    DELINQUENCY = "delinquency"
    HIGH_RATE = "high_rate"
    COMPLEXITY = "complexity"


class RecommendationCategory(str, Enum):
    """Recommendation categories for NBA mapping"""
    CASH_FLOW = "cash_flow"
    STRESS_REDUCTION = "stress_reduction"
    DELINQUENCY = "delinquency"
    INTEREST_COST = "interest_cost"
    COMPLEXITY = "complexity"


# ============================================================================
# Input Models
# ============================================================================

class Goal(str, Enum):
    """User's primary financial goal"""
    REDUCE_STRESS = "reduce_stress"
    LOWER_PAYMENTS = "lower_payments"
    BECOME_DEBT_FREE = "become_debt_free"
    BUILD_SAVINGS = "build_savings"
    IMPROVE_CREDIT = "improve_credit"


class StressLevel(str, Enum):
    """User's self-reported stress level"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


class EmploymentStatus(str, Enum):
    """User's employment situation"""
    STABLE = "stable"
    VARIABLE = "variable"
    TRANSITIONING = "transitioning"
    UNEMPLOYED = "unemployed"


class LifeEvent(str, Enum):
    """Current major life events"""
    NONE = "none"
    BABY = "baby"
    MOVE = "move"
    JOB_CHANGE = "job_change"
    MARRIAGE = "marriage"
    DIVORCE = "divorce"
    MEDICAL = "medical"
    EDUCATION = "education"


class AgeRange(str, Enum):
    """User's age bracket"""
    UNDER_25 = "under_25"
    AGE_25_34 = "25_34"
    AGE_35_44 = "35_44"
    AGE_45_54 = "45_54"
    AGE_55_64 = "55_64"
    AGE_65_PLUS = "65_plus"


class DebtInput(BaseModel):
    """Individual debt for risk calculation"""
    balance: float = Field(ge=0, description="Current balance in dollars")
    apr: float = Field(ge=0, le=100, description="Annual percentage rate (0-100)")
    is_delinquent: bool = Field(default=False, description="Whether debt is currently delinquent")


class UserContext(BaseModel):
    """User context for personalized UX copy"""
    goal: Goal = Field(description="User's primary financial goal")
    stress_level: StressLevel = Field(description="User's stress level")
    employment_status: EmploymentStatus = Field(description="Employment situation")
    life_events: LifeEvent = Field(description="Current major life events")
    age_range: AgeRange = Field(description="User's age bracket")


# ============================================================================
# Output Models
# ============================================================================

class RiskDrivers(BaseModel):
    """Individual risk factor components"""
    delinquency_factor: float = Field(ge=0, le=1, description="Delinquency factor (D)")
    high_rate_factor: float = Field(ge=0, le=1, description="High-rate debt factor (H)")
    complexity_factor: float = Field(ge=0, le=1, description="Complexity factor (C)")


class DeterministicRiskOutput(BaseModel):
    """Output from deterministic calculation layer"""
    risk_score: float = Field(ge=0, le=100, description="Debt composition risk score")
    risk_band: RiskBand = Field(description="Risk classification band")
    drivers: RiskDrivers = Field(description="Individual risk factors")
    driver_severity: List[DriverType] = Field(description="Drivers sorted by weighted score impact")
    primary_driver: DriverType = Field(description="Single most impactful driver")
    debt_count: int = Field(gt=0, description="Total number of debts")


class FinancialInterpretation(BaseModel):
    """Structured financial interpretation (deterministic)"""
    summary: str = Field(
        min_length=50,
        max_length=500,
        description="What the score means financially"
    )
    key_drivers: List[str] = Field(description="Ranked list of risk drivers with impact percentages")
    interpretation_points: List[str] = Field(
        min_length=2,
        max_length=4,
        description="2-4 specific interpretation points (1 per significant driver)"
    )


class RecommendationItem(BaseModel):
    """Single recommendation with metadata"""
    text: str = Field(
        min_length=10,
        max_length=500,
        description="Recommendation text (10-500 chars)"
    )
    category: RecommendationCategory = Field(
        description="Category for NBA mapping"
    )
    priority: int = Field(
        ge=1,
        le=5,
        description="Priority 1-5 (1 = highest)"
    )
    action_id: Optional[str] = Field(
        None,
        description="Maps to NBA action if applicable"
    )


class PersonalizedUXCopy(BaseModel):
    """LLM-generated personalized UX copy"""
    user_friendly_summary: str = Field(
        min_length=100,
        max_length=300,
        description="2-3 sentence summary (100-300 chars)"
    )
    personalized_recommendations: List[RecommendationItem] = Field(
        min_length=3,
        max_length=5,
        description="3-5 personalized recommendations"
    )
    closing_message: str = Field(
        min_length=50,
        max_length=150,
        description="Encouraging, goal-aligned closing (50-150 chars)"
    )


class FinancialAssessmentResult(BaseModel):
    """Complete financial assessment result"""
    assessment_version: str = Field(default="1.0.0", description="Assessment version")
    generated_at: str = Field(description="ISO 8601 timestamp")
    deterministic_output: DeterministicRiskOutput
    financial_interpretation: FinancialInterpretation
    personalized_ux: PersonalizedUXCopy


# ============================================================================
# Layer 1: Deterministic Calculation
# ============================================================================

class DeterministicCalculator:
    """
    Computes debt composition risk score with no AI involvement.
    
    Formula: Risk Score = (D × 50) + (H × 30) + (C × 20)
    Range: 0-100 (higher = more risk)
    """
    
    # Configuration constants
    HIGH_RATE_THRESHOLD = 15.0  # APR threshold for high-rate debt
    COMPLEXITY_BASE = 3  # Baseline number of debts
    COMPLEXITY_RANGE = 7  # Range for complexity calculation
    
    @staticmethod
    def calculate_delinquency_factor(debts: List[DebtInput]) -> float:
        """
        Calculate delinquency factor (D).
        
        D = min(1.0, delinquent_count / total_debts)
        """
        if not debts:
            return 0.0
        
        delinquent_count = sum(1 for debt in debts if debt.is_delinquent)
        return min(1.0, delinquent_count / len(debts))
    
    @staticmethod
    def calculate_high_rate_factor(debts: List[DebtInput]) -> float:
        """
        Calculate high-rate debt factor (H).
        
        H = high_rate_balance / total_balance
        where high_rate_balance = sum of balances with APR ≥ 20%
        """
        if not debts:
            return 0.0
        
        total_balance = sum(debt.balance for debt in debts)
        if total_balance == 0:
            return 0.0
        
        high_rate_balance = sum(
            debt.balance for debt in debts 
            if debt.apr >= DeterministicCalculator.HIGH_RATE_THRESHOLD
        )
        
        return high_rate_balance / total_balance
    
    @staticmethod
    def calculate_complexity_factor(debts: List[DebtInput]) -> float:
        """
        Calculate complexity factor (C).
        
        C = min(1.0, (debt_count - 3) / 7)
        """
        if not debts:
            return 0.0
        
        debt_count = len(debts)
        complexity = (debt_count - DeterministicCalculator.COMPLEXITY_BASE) / DeterministicCalculator.COMPLEXITY_RANGE
        return min(1.0, max(0.0, complexity))
    
    @staticmethod
    def calculate_risk_score(
        delinquency_factor: float,
        high_rate_factor: float,
        complexity_factor: float
    ) -> float:
        """
        Calculate overall risk score.
        
        Risk Score = (D × 50) + (H × 30) + (C × 20)
        """
        score = (delinquency_factor * 50) + (high_rate_factor * 30) + (complexity_factor * 20)
        return round(score, 2)
    
    @staticmethod
    def determine_risk_band(risk_score: float) -> RiskBand:
        """
        Determine risk band from score.
        
        Score ranges:
        - 0-14: excellent
        - 15-29: low_moderate
        - 30-49: moderate
        - 50-69: high
        - 70-100: critical
        """
        if risk_score <= 14:
            return RiskBand.EXCELLENT
        elif risk_score <= 29:
            return RiskBand.LOW_MODERATE
        elif risk_score <= 49:
            return RiskBand.MODERATE
        elif risk_score <= 69:
            return RiskBand.HIGH
        else:
            return RiskBand.CRITICAL
    
    @staticmethod
    def rank_drivers(drivers: RiskDrivers) -> List[DriverType]:
        """
        Rank drivers by weighted score impact (not just factor value).
        
        This sorts by actual contribution to final score:
        - Delinquency: factor × 50
        - High Rate: factor × 30
        - Complexity: factor × 20
        
        This ensures LLM focuses on most financially meaningful driver.
        """
        driver_impacts = [
            (DriverType.DELINQUENCY, drivers.delinquency_factor * 50),
            (DriverType.HIGH_RATE, drivers.high_rate_factor * 30),
            (DriverType.COMPLEXITY, drivers.complexity_factor * 20)
        ]
        
        # Sort by weighted impact descending
        sorted_drivers = sorted(driver_impacts, key=lambda x: x[1], reverse=True)
        
        return [driver_type for driver_type, _ in sorted_drivers]
    
    @classmethod
    def calculate(cls, debts: List[DebtInput]) -> DeterministicRiskOutput:
        """
        Execute complete deterministic calculation.
        
        Returns:
            DeterministicRiskOutput with score, band, drivers, severity ranking, 
            primary driver, and debt count
        """
        # Calculate individual factors
        delinquency_factor = cls.calculate_delinquency_factor(debts)
        high_rate_factor = cls.calculate_high_rate_factor(debts)
        complexity_factor = cls.calculate_complexity_factor(debts)
        
        # Create drivers object
        drivers = RiskDrivers(
            delinquency_factor=delinquency_factor,
            high_rate_factor=high_rate_factor,
            complexity_factor=complexity_factor
        )
        
        # Calculate overall score
        risk_score = cls.calculate_risk_score(
            delinquency_factor,
            high_rate_factor,
            complexity_factor
        )
        
        # Determine risk band
        risk_band = cls.determine_risk_band(risk_score)
        
        # Rank drivers by weighted impact
        driver_severity = cls.rank_drivers(drivers)
        
        # Primary driver is the first (highest impact)
        primary_driver = driver_severity[0]
        
        # Get debt count
        debt_count = len(debts)
        
        return DeterministicRiskOutput(
            risk_score=risk_score,
            risk_band=risk_band,
            drivers=drivers,
            driver_severity=driver_severity,
            primary_driver=primary_driver,
            debt_count=debt_count
        )


# ============================================================================
# Layer 2: Deterministic Financial Interpretation
# ============================================================================

class FinancialInterpreter:
    """
    Generates structured, rule-based interpretation of risk score.
    No AI involvement - purely deterministic logic.
    """
    
    # Risk band descriptions
    RISK_BAND_DESCRIPTIONS = {
        RiskBand.EXCELLENT: "Very low risk",
        RiskBand.LOW_MODERATE: "Minor risk factors",
        RiskBand.MODERATE: "Multiple emerging risks",
        RiskBand.HIGH: "High-cost or hard-to-manage debt",
        RiskBand.CRITICAL: "Severe risk; likely financial strain"
    }
    
    # High rate threshold for interpretation
    HIGH_RATE_THRESHOLD = 15.0
    
    @classmethod
    def generate_summary(
        cls,
        risk_output: DeterministicRiskOutput,
        debt_count: int
    ) -> str:
        """Generate summary explaining what the score means."""
        band_desc = cls.RISK_BAND_DESCRIPTIONS[risk_output.risk_band]
        
        if risk_output.risk_band == RiskBand.EXCELLENT:
            return f"Your debt composition shows {band_desc.lower()} with a score of {risk_output.risk_score:.0f}/100. Your {debt_count} debt(s) are well-structured and manageable."
        elif risk_output.risk_band == RiskBand.LOW_MODERATE:
            return f"Your debt composition shows {band_desc.lower()} with a score of {risk_output.risk_score:.0f}/100. There are some areas to monitor across your {debt_count} debt(s)."
        elif risk_output.risk_band == RiskBand.MODERATE:
            return f"Your debt composition indicates {band_desc.lower()} with a score of {risk_output.risk_score:.0f}/100. Your {debt_count} debt(s) have several factors that need attention."
        elif risk_output.risk_band == RiskBand.HIGH:
            return f"Your debt composition shows {band_desc.lower()} with a score of {risk_output.risk_score:.0f}/100. Your {debt_count} debt(s) are creating significant financial pressure."
        else:  # CRITICAL
            return f"Your debt composition indicates {band_desc.lower()} with a score of {risk_output.risk_score:.0f}/100. Your {debt_count} debt(s) require immediate attention to avoid further strain."
    
    @classmethod
    def generate_key_drivers(
        cls,
        risk_output: DeterministicRiskOutput
    ) -> List[str]:
        """Generate ranked list of key drivers with impact percentages."""
        key_drivers = []
        
        for driver_type in risk_output.driver_severity:
            driver_value = getattr(risk_output.drivers, f"{driver_type.value}_factor")
            
            # Calculate weighted contribution
            if driver_type == DriverType.DELINQUENCY:
                contribution = driver_value * 50
            elif driver_type == DriverType.HIGH_RATE:
                contribution = driver_value * 30
            else:  # COMPLEXITY
                contribution = driver_value * 20
            
            # Only include drivers with ≥10 points contribution
            if contribution >= 10:
                driver_name = driver_type.value.replace("_", " ").title()
                percentage = int(driver_value * 100)
                key_drivers.append(f"{driver_name} ({percentage}% impact)")
        
        return key_drivers
    
    @classmethod
    def generate_interpretation_points(
        cls,
        risk_output: DeterministicRiskOutput,
        debts: List[DebtInput]
    ) -> List[str]:
        """
        Generate 2-4 dynamic, data-grounded interpretation points.
        
        Rule: 1 point per driver with ≥10 points contribution to score.
        If fewer than 2 drivers meet threshold, add context about risk band.
        """
        points = []
        
        # Add interpretation for each significant driver (≥10 points contribution)
        for driver_type in risk_output.driver_severity:
            driver_value = getattr(risk_output.drivers, f"{driver_type.value}_factor")
            
            # Calculate weighted contribution
            if driver_type == DriverType.DELINQUENCY:
                contribution = driver_value * 50
            elif driver_type == DriverType.HIGH_RATE:
                contribution = driver_value * 30
            else:  # COMPLEXITY
                contribution = driver_value * 20
            
            # Only include if contribution ≥ 10 points
            if contribution >= 10:
                if driver_type == DriverType.DELINQUENCY:
                    delinquent_count = sum(1 for debt in debts if debt.is_delinquent)
                    points.append(
                        f"{delinquent_count} of your {risk_output.debt_count} debts "
                        f"{'is' if delinquent_count == 1 else 'are'} currently delinquent, "
                        f"indicating missed payments"
                    )
                    
                elif driver_type == DriverType.HIGH_RATE:
                    high_rate_count = sum(1 for debt in debts if debt.apr >= cls.HIGH_RATE_THRESHOLD)
                    percentage = int(driver_value * 100)
                    points.append(
                        f"About {percentage}% of your total debt carries interest rates ≥15% "
                        f"({high_rate_count} {'account' if high_rate_count == 1 else 'accounts'}), "
                        f"which adds significant monthly cost"
                    )
                    
                elif driver_type == DriverType.COMPLEXITY:
                    points.append(
                        f"Managing {risk_output.debt_count} separate debt accounts "
                        f"increases administrative burden and the chance of missed payments"
                    )
        
        # Ensure we have at least 2 points as per specification
        if len(points) < 2:
            if risk_output.risk_band == RiskBand.EXCELLENT:
                points.append("Your debt structure is well-managed with low interest rates")
                if len(points) < 2:
                    points.append(f"With {risk_output.debt_count} debt(s), you have a simple and sustainable debt load")
            elif risk_output.risk_band == RiskBand.LOW_MODERATE:
                points.append("Your debt has minor risk factors worth monitoring")
                if len(points) < 2:
                    points.append("Continue making consistent payments to maintain this healthy position")
            elif risk_output.risk_band == RiskBand.MODERATE:
                points.append("Multiple risk factors are emerging that need attention")
                if len(points) < 2:
                    points.append("Taking action now can prevent these risks from escalating")
            elif risk_output.risk_band in [RiskBand.HIGH, RiskBand.CRITICAL]:
                points.append("Current debt structure may be difficult to sustain long-term")
                if len(points) < 2:
                    points.append("Immediate action is recommended to improve your debt situation")
        
        return points[:4]  # Maximum 4 points
    
    @classmethod
    def interpret(
        cls,
        risk_output: DeterministicRiskOutput,
        debts: List[DebtInput]
    ) -> FinancialInterpretation:
        """
        Generate complete financial interpretation.
        
        Returns:
            FinancialInterpretation with summary, drivers, and interpretation points
        """
        summary = cls.generate_summary(risk_output, risk_output.debt_count)
        key_drivers = cls.generate_key_drivers(risk_output)
        interpretation_points = cls.generate_interpretation_points(risk_output, debts)
        
        return FinancialInterpretation(
            summary=summary,
            key_drivers=key_drivers,
            interpretation_points=interpretation_points
        )


# ============================================================================
# Layer 3: AI-Generated UX Copy
# ============================================================================

class UXCopyGenerator:
    """
    Generates personalized UX copy using LLM with controlled prompts.
    """
    
    # Backup UX copy for fallback or prompt anchoring
    BACKUP_UX_COPY = {
        "risk_bands": {
            RiskBand.EXCELLENT: "Your debt mix is well-structured and manageable.",
            RiskBand.LOW_MODERATE: "Your debt has minor risk factors worth monitoring.",
            RiskBand.MODERATE: "Multiple risk factors are emerging, such as interest burden or complexity.",
            RiskBand.HIGH: "Your debt mix is costly or difficult to manage, likely impacting your budget.",
            RiskBand.CRITICAL: "Your debt situation requires immediate attention to prevent further strain."
        },
        "drivers": {
            DriverType.DELINQUENCY: "Missed payments suggest the current structure may be hard to keep up with.",
            DriverType.HIGH_RATE: "Interest costs are consuming a large share of each payment.",
            DriverType.COMPLEXITY: "Managing many accounts increases the chance of errors or stress."
        },
        "stress_levels": {
            "high": "Let's reduce overwhelm step-by-step so this feels manageable.",
            "medium": "We'll work together to make this more manageable.",
            "low": "You're in a good position to tackle this strategically."
        },
        "life_events": {
            "baby": "Stabilizing your debt now can help you plan confidently for your growing family.",
            "move": "Getting your debt under control will make your transition smoother.",
            "job_change": "Stabilizing your debt now can help you navigate this career transition.",
            "none": "Now is a great time to optimize your debt strategy."
        }
    }
    
    @classmethod
    def build_prompt(
        cls,
        risk_output: DeterministicRiskOutput,
        interpretation: FinancialInterpretation,
        user_context: UserContext
    ) -> str:
        """
        Build controlled prompt for LLM.
        
        The prompt includes:
        - System instructions
        - Context inputs (risk data)
        - User context
        - Task definition
        - Tone guidelines
        - Backup UX copy for anchoring
        """
        # Format driver severity for prompt
        driver_list = ", ".join([d.value.replace("_", " ") for d in risk_output.driver_severity])
        primary_driver_name = risk_output.primary_driver.value.replace("_", " ")
        
        # Format interpretation points
        interp_points = "\n".join([f"- {point}" for point in interpretation.interpretation_points])
        
        prompt = f"""SYSTEM:
You are a financial coach. Your tone is calm, encouraging, accurate, and non-judgmental.
Explain financial risk clearly and simply. Avoid legal or tax instructions.

CONTEXT INPUTS:
- Risk Score: {risk_output.risk_score:.0f}/100
- Risk Band: {risk_output.risk_band.value}
- Total Debts: {risk_output.debt_count}
- Primary Driver: {primary_driver_name}
- All Drivers (by impact): {driver_list}
- Financial Interpretation Summary: {interpretation.summary}
- Interpretation Points:
{interp_points}

USER CONTEXT:
- Goal: {user_context.goal.value}
- Stress Level: {user_context.stress_level.value}
- Employment: {user_context.employment_status.value}
- Life Events: {user_context.life_events.value}
- Age Range: {user_context.age_range.value}

TASK:
1. Provide a 2-3 sentence summary of what this debt composition score means.
2. Provide specific, personalized recommendations (3-5 bullets) that include:
   - Actionable steps based on their primary risk driver
   - Debt payoff strategy recommendations (avalanche for high-rate debt, snowball for stress reduction)
   - Specific actions they can take (e.g., "Compare payoff scenarios", "Consider consolidation")
3. Provide an encouraging, goal-aligned closing line.

RECOMMENDATION GUIDELINES:
- If primary driver is HIGH_RATE: Recommend avalanche method (highest interest first) and exploring scenarios
- If primary driver is DELINQUENCY: Recommend addressing delinquent accounts immediately
- If primary driver is COMPLEXITY: Recommend consolidation or simplification strategies
- If goal is REDUCE_STRESS: Suggest snowball method (smallest balance first) for quick wins
- If goal is BECOME_DEBT_FREE: Focus on fastest payoff strategies
- If goal is LOWER_PAYMENTS: Suggest refinancing or consolidation options

Tone guidelines:
- Encourage and support.
- Avoid judgment.
- Avoid technical jargon unless explained simply.
- Be specific about which payoff strategy might work best for them.

BACKUP UX COPY (Reference Only):
- Risk Band Context: "{cls.BACKUP_UX_COPY['risk_bands'][risk_output.risk_band]}"
- Stress Level: "{cls.BACKUP_UX_COPY['stress_levels'].get(user_context.stress_level.value, '')}"
- Life Events: "{cls.BACKUP_UX_COPY['life_events'].get(user_context.life_events.value, cls.BACKUP_UX_COPY['life_events']['none'])}"

Return your response as JSON with these exact keys:
{{
  "user_friendly_summary": "<2-3 sentences>",
  "personalized_recommendations": ["<bullet 1>", "<bullet 2>", "<bullet 3>", ...],
  "closing_message": "<encouraging closing>"
}}"""
        
        return prompt
    
    @classmethod
    def generate_fallback_ux(
        cls,
        risk_output: DeterministicRiskOutput,
        interpretation: FinancialInterpretation,
        user_context: UserContext
    ) -> PersonalizedUXCopy:
        """
        Generate fallback UX copy without LLM (for errors or testing).
        """
        # Use backup copy for summary
        summary = f"{cls.BACKUP_UX_COPY['risk_bands'][risk_output.risk_band]} {interpretation.summary}"
        
        # Generate basic recommendations as RecommendationItem objects
        recommendations = []
        priority = 1
        
        # Add driver-based recommendations with payoff strategy context
        for driver_type in risk_output.driver_severity[:3]:  # Top 3 drivers
            driver_value = getattr(risk_output.drivers, f"{driver_type.value}_factor")
            if driver_value > 0.1:
                # Map driver to category and provide strategy-specific recommendations
                if driver_type == DriverType.DELINQUENCY:
                    category = RecommendationCategory.DELINQUENCY
                    action_id = "address-delinquency"
                    text = "Address delinquent accounts immediately to avoid further penalties and credit damage."
                elif driver_type == DriverType.HIGH_RATE:
                    category = RecommendationCategory.INTEREST_COST
                    action_id = "high-interest-focus"
                    # Recommend avalanche method for high-rate debt
                    text = "Focus on your highest-interest debts first (avalanche method) to minimize total interest paid."
                else:  # COMPLEXITY
                    category = RecommendationCategory.COMPLEXITY
                    action_id = "consolidate-debts"
                    text = "Consider consolidating multiple debts to simplify payments and potentially lower your interest rate."
                
                recommendations.append(RecommendationItem(
                    text=text,
                    category=category,
                    priority=priority,
                    action_id=action_id
                ))
                priority += 1
        
        # Add goal-based recommendations
        if user_context.goal == Goal.REDUCE_STRESS and len(recommendations) < 5:
            recommendations.append(RecommendationItem(
                text="Try the snowball method: pay off smallest debts first for quick wins and motivation.",
                category=RecommendationCategory.STRESS_REDUCTION,
                priority=priority,
                action_id="review-strategy"
            ))
            priority += 1
        elif user_context.goal == Goal.BECOME_DEBT_FREE and len(recommendations) < 5:
            recommendations.append(RecommendationItem(
                text="Explore debt payoff scenarios to find the fastest path to becoming debt-free.",
                category=RecommendationCategory.CASH_FLOW,
                priority=priority,
                action_id="review-strategy"
            ))
            priority += 1
        elif user_context.goal == Goal.LOWER_PAYMENTS and len(recommendations) < 5:
            recommendations.append(RecommendationItem(
                text="Investigate refinancing or consolidation options to reduce your monthly payment burden.",
                category=RecommendationCategory.CASH_FLOW,
                priority=priority,
                action_id="consolidate-debts"
            ))
            priority += 1
        
        # Add stress-based recommendation if high stress
        if user_context.stress_level == StressLevel.HIGH and len(recommendations) < 5:
            recommendations.append(RecommendationItem(
                text="Start with small, manageable steps. Even small progress can reduce financial stress.",
                category=RecommendationCategory.STRESS_REDUCTION,
                priority=priority,
                action_id=None
            ))
            priority += 1
        
        # Ensure we have at least 3 recommendations
        while len(recommendations) < 3:
            recommendations.append(RecommendationItem(
                text="Compare different payoff strategies to find the best approach for your situation.",
                category=RecommendationCategory.CASH_FLOW,
                priority=priority,
                action_id="review-strategy"
            ))
            priority += 1
        
        # Generate closing message
        closing = cls.BACKUP_UX_COPY['life_events'].get(
            user_context.life_events.value,
            cls.BACKUP_UX_COPY['life_events']['none']
        )
        
        return PersonalizedUXCopy(
            user_friendly_summary=summary,
            personalized_recommendations=recommendations[:5],  # Max 5
            closing_message=closing
        )
    
    @classmethod
    async def generate(
        cls,
        risk_output: DeterministicRiskOutput,
        interpretation: FinancialInterpretation,
        user_context: UserContext,
        ai_service: Optional[Any] = None
    ) -> PersonalizedUXCopy:
        """
        Generate personalized UX copy using LLM.
        
        Args:
            risk_output: Deterministic risk calculation output
            interpretation: Financial interpretation
            user_context: User context for personalization
            ai_service: Optional AI service for LLM calls
            
        Returns:
            PersonalizedUXCopy with summary, recommendations, and closing
        """
        # Build prompt
        prompt = cls.build_prompt(risk_output, interpretation, user_context)
        
        # If no AI service provided, use fallback
        if ai_service is None:
            logger.warning("No AI service provided, using fallback UX copy")
            return cls.generate_fallback_ux(risk_output, interpretation, user_context)
        
        try:
            # Call LLM (implementation depends on AI service interface)
            # This is a placeholder - actual implementation will depend on your AI service
            response = await ai_service.generate_structured_response(
                prompt=prompt,
                response_model=PersonalizedUXCopy
            )
            
            return response
            
        except Exception as e:
            logger.error(f"Error generating UX copy with LLM: {e}")
            logger.info("Falling back to deterministic UX copy")
            return cls.generate_fallback_ux(risk_output, interpretation, user_context)


# ============================================================================
# Main Assessment Function
# ============================================================================

async def assess_financial_health(
    debts: List[DebtInput],
    user_context: UserContext,
    ai_service: Optional[Any] = None
) -> FinancialAssessmentResult:
    """
    Execute complete financial health assessment.
    
    This is the main entry point that orchestrates all three layers:
    1. Deterministic calculation
    2. Financial interpretation
    3. AI-generated UX copy
    
    Args:
        debts: List of user's debts
        user_context: User context for personalization
        ai_service: Optional AI service for LLM calls
        
    Returns:
        FinancialAssessmentResult with all three layers of output
    """
    # Layer 1: Deterministic calculation
    risk_output = DeterministicCalculator.calculate(debts)
    
    # Layer 2: Financial interpretation
    interpretation = FinancialInterpreter.interpret(risk_output, debts)
    
    # Layer 3: AI-generated UX copy
    personalized_ux = await UXCopyGenerator.generate(
        risk_output,
        interpretation,
        user_context,
        ai_service
    )
    
    # Add timestamp
    from datetime import datetime, timezone
    generated_at = datetime.now(timezone.utc).isoformat()
    
    return FinancialAssessmentResult(
        assessment_version="1.0.0",
        generated_at=generated_at,
        deterministic_output=risk_output,
        financial_interpretation=interpretation,
        personalized_ux=personalized_ux
    )